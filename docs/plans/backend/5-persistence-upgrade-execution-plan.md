# Persistence Upgrade Execution Plan

This document captures the refreshed execution plan derived from `docs/plans/backend/4-persistence-migration-plan.md` and the current repository gaps surfaced in the IDE review. It is intended to guide ongoing backend work, starting with the `sqlc` migration and extending through testing and operational hardening.

## Phase 1 – Reinstate `sqlc` Generators

**Objective**
- Replace handwritten SQL strings with typed accessors generated by `sqlc` to regain compile-time safety and keep queries in `.sql` files.

**Key Tasks**
- Keep `sqlc.yaml` authoritative and wire `sqlc generate` into the developer workflow.
- Emit generated code into `internal/infra/persistence/postgres/sqlc/` and wrap it with thin adapters that satisfy the `internal/domain/*store` interfaces.
- Delete or migrate hard-coded statements such as `orderInsertSQL` in `internal/infra/persistence/postgres/order_store.go`.
- Document regeneration steps in `docs/development/migrations.md` and ensure `make lint` / `make test` run clean with the new code.

**Exit Criteria**
- No production package embeds raw SQL literals.
- `sqlc generate` succeeds deterministically and outputs tracked code.
- Persistence interfaces compile against generated implementations.
- `make lint` and `make test` pass.

## Phase 2 – Migration Hygiene & Backlog

**Objective**
- Maintain a trustworthy, replayable schema history under `db/migrations/`.

**Key Tasks**
- Treat `0001_init` and `0002_strategy_instance_identifiers` as the baseline; add any missing evolution steps the blueprint requires (providers, routes, orders, executions, balances, strategy instances, outbox).
- Automate `make migrate`/`make migrate-down` usage (CI, dev docs) and keep instructions up to date in `docs/development/migrations.md`.
- Gate new persistence work on paired up/down SQL plus regeneration of corresponding `sqlc` bindings.

**Exit Criteria**
- Every table/constraint mentioned in the blueprint exists in sequenced migrations.
- Developers can bootstrap a database from scratch using `make migrate`.
- Rollbacks (`make migrate-down`) function at least one step back.
- Documentation reflects the latest process.

## Phase 3 – Contract-Level Integration Tests

**Objective**
- Exercise the persistence layer against a real Postgres instance to catch regressions that unit tests miss.

**Key Tasks**
- Create `tests/contract/persistence/` and implement Go tests that spin up Docker/Postgres (Testcontainers), apply migrations, and run CRUD flows for providers, strategies, orders, executions, balances, and the outbox.
- Place shared fixtures under `test/` (per `test/README.md`) and reuse them across suites.
- Add these tests to `make test` so they run locally and in CI.

**Exit Criteria**
- Contract tests fail when migrations, SQL, or adapters regress.
- Developers can run `make test` without additional manual steps.
- Testcontainers usage is documented (prereqs, environment flags).

## Phase 4 – Clarify Write-Through Cache Semantics

**Objective**
- Align the implementation with the plan’s “write-through cache” requirement so everyone understands what data stays hot in memory.

**Key Tasks**
- Document the existing provider snapshot/route caching in `internal/app/provider/manager.go` and how it persists to Postgres.
- Decide whether orders, executions, and balances also need in-memory mirrors. If yes, implement caches with transactional persistence; if not, update the plan to state that only provider routing uses the write-through pattern.
- Record the decision in the docs alongside any telemetry implications.

**Exit Criteria**
- The code and documentation agree on which domains leverage write-through caching.
- Operators know where to expect cached state versus DB-only state.

## Phase 5 – Operational Docs & Telemetry

**Objective**
- Keep operators and developers informed as the persistence stack evolves.

**Key Tasks**
- Update `docs/dashboards/README.md` (and JSON dashboards) whenever persistence metrics or panels change.
- Extend `docs/development/migrations.md` with `sqlc` regeneration, migration rollback procedures, and contract-test troubleshooting tips.
- Ensure telemetry points (`TELEMETRY_POINTS.md`, dashboards) cover database health, migration status, and cache hit/miss rates where applicable.

**Exit Criteria**
- Runbooks explain how to regenerate SQL bindings, apply/rollback migrations, and diagnose persistence issues.
- Grafana dashboards reflect current metrics and link to the new persistence pathways.
- Every code change that alters telemetry ships with documentation updates.

## Validation Gate

- After completing any phase or significant subtask, run `make lint` followed by `make test`. Treat failures as blockers before merging or deploying.

