// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: strategy_instances.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteStrategyInstance = `-- name: DeleteStrategyInstance :exec
DELETE FROM strategy_instances WHERE instance_id = $1::text
`

func (q *Queries) DeleteStrategyInstance(ctx context.Context, instanceID string) error {
	_, err := q.db.Exec(ctx, deleteStrategyInstance, instanceID)
	return err
}

const getStrategyInternalID = `-- name: GetStrategyInternalID :one
SELECT id FROM strategy_instances WHERE instance_id = $1::text
`

func (q *Queries) GetStrategyInternalID(ctx context.Context, instanceID string) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getStrategyInternalID, instanceID)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const listStrategyInstances = `-- name: ListStrategyInstances :many
SELECT id, strategy_identifier, version, status, config_hash, description, metadata, created_at, updated_at, instance_id
FROM strategy_instances
ORDER BY instance_id
`

func (q *Queries) ListStrategyInstances(ctx context.Context) ([]StrategyInstance, error) {
	rows, err := q.db.Query(ctx, listStrategyInstances)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StrategyInstance
	for rows.Next() {
		var i StrategyInstance
		if err := rows.Scan(
			&i.ID,
			&i.StrategyIdentifier,
			&i.Version,
			&i.Status,
			&i.ConfigHash,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InstanceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertStrategyInstance = `-- name: UpsertStrategyInstance :one
INSERT INTO strategy_instances (
    instance_id,
    strategy_identifier,
    version,
    status,
    config_hash,
    description,
    metadata,
    updated_at
)
VALUES (
    $1::text,
    $2::text,
    $3::text,
    $4::text,
    $5::text,
    COALESCE($6::text, ''),
    COALESCE($7::jsonb, '{}'::jsonb),
    NOW()
)
ON CONFLICT (instance_id) DO
UPDATE SET
    strategy_identifier = EXCLUDED.strategy_identifier,
    version = EXCLUDED.version,
    status = EXCLUDED.status,
    config_hash = EXCLUDED.config_hash,
    description = EXCLUDED.description,
    metadata = EXCLUDED.metadata,
    updated_at = NOW()
RETURNING id, strategy_identifier, version, status, config_hash, description, metadata, created_at, updated_at, instance_id
`

type UpsertStrategyInstanceParams struct {
	InstanceID         string `db:"instance_id" json:"instance_id"`
	StrategyIdentifier string `db:"strategy_identifier" json:"strategy_identifier"`
	Version            string `db:"version" json:"version"`
	Status             string `db:"status" json:"status"`
	ConfigHash         string `db:"config_hash" json:"config_hash"`
	Description        string `db:"description" json:"description"`
	Metadata           []byte `db:"metadata" json:"metadata"`
}

func (q *Queries) UpsertStrategyInstance(ctx context.Context, arg UpsertStrategyInstanceParams) (StrategyInstance, error) {
	row := q.db.QueryRow(ctx, upsertStrategyInstance,
		arg.InstanceID,
		arg.StrategyIdentifier,
		arg.Version,
		arg.Status,
		arg.ConfigHash,
		arg.Description,
		arg.Metadata,
	)
	var i StrategyInstance
	err := row.Scan(
		&i.ID,
		&i.StrategyIdentifier,
		&i.Version,
		&i.Status,
		&i.ConfigHash,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InstanceID,
	)
	return i, err
}
