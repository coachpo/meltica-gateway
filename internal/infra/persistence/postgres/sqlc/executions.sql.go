// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: executions.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const insertExecution = `-- name: InsertExecution :one
INSERT INTO executions (
    order_id,
    provider_id,
    execution_id,
    fill_quantity,
    fill_price,
    fee,
    fee_asset,
    liquidity,
    traded_at,
    metadata
)
VALUES (
    $1::uuid,
    $2::bigint,
    $3::text,
    $4::numeric,
    $5::numeric,
    $6::numeric,
    $7::text,
    $8::text,
    $9::timestamptz,
    COALESCE($10::jsonb, '{}'::jsonb)
)
ON CONFLICT (order_id, execution_id) DO UPDATE
SET
    fill_quantity = EXCLUDED.fill_quantity,
    fill_price = EXCLUDED.fill_price,
    fee = EXCLUDED.fee,
    fee_asset = EXCLUDED.fee_asset,
    liquidity = EXCLUDED.liquidity,
    traded_at = EXCLUDED.traded_at,
    metadata = EXCLUDED.metadata
RETURNING id, order_id, provider_id, execution_id, fill_quantity, fill_price, fee, fee_asset, liquidity, traded_at, metadata, created_at
`

type InsertExecutionParams struct {
	OrderID      pgtype.UUID        `db:"order_id" json:"order_id"`
	ProviderID   int64              `db:"provider_id" json:"provider_id"`
	ExecutionID  string             `db:"execution_id" json:"execution_id"`
	FillQuantity pgtype.Numeric     `db:"fill_quantity" json:"fill_quantity"`
	FillPrice    pgtype.Numeric     `db:"fill_price" json:"fill_price"`
	Fee          pgtype.Numeric     `db:"fee" json:"fee"`
	FeeAsset     pgtype.Text        `db:"fee_asset" json:"fee_asset"`
	Liquidity    string             `db:"liquidity" json:"liquidity"`
	TradedAt     pgtype.Timestamptz `db:"traded_at" json:"traded_at"`
	Metadata     []byte             `db:"metadata" json:"metadata"`
}

func (q *Queries) InsertExecution(ctx context.Context, arg InsertExecutionParams) (Execution, error) {
	row := q.db.QueryRow(ctx, insertExecution,
		arg.OrderID,
		arg.ProviderID,
		arg.ExecutionID,
		arg.FillQuantity,
		arg.FillPrice,
		arg.Fee,
		arg.FeeAsset,
		arg.Liquidity,
		arg.TradedAt,
		arg.Metadata,
	)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProviderID,
		&i.ExecutionID,
		&i.FillQuantity,
		&i.FillPrice,
		&i.Fee,
		&i.FeeAsset,
		&i.Liquidity,
		&i.TradedAt,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const listExecutions = `-- name: ListExecutions :many
SELECT
    e.order_id::text AS order_id,
    p.alias AS provider_alias,
    COALESCE(si.instance_id, '') AS strategy_instance_id,
    e.execution_id,
    e.fill_quantity::text AS fill_quantity_text,
    e.fill_price::text AS fill_price_text,
    COALESCE(e.fee::text, ''::text)::text AS fee_text,
    e.fee_asset,
    e.liquidity,
    e.traded_at,
    e.metadata AS metadata_json,
    e.created_at
FROM executions e
JOIN orders o ON o.id = e.order_id
JOIN providers p ON p.id = e.provider_id
LEFT JOIN strategy_instances si ON si.id = o.strategy_instance_id
WHERE (
    $1::text IS NULL
    OR COALESCE(si.instance_id, '') = $1::text
) AND (
    $2::text IS NULL
    OR p.alias = $2::text
) AND (
    $3::uuid IS NULL
    OR e.order_id = $3::uuid
)
ORDER BY e.traded_at DESC
LIMIT $4::int
`

type ListExecutionsParams struct {
	StrategyInstance pgtype.Text `db:"strategy_instance" json:"strategy_instance"`
	ProviderAlias    pgtype.Text `db:"provider_alias" json:"provider_alias"`
	OrderID          pgtype.UUID `db:"order_id" json:"order_id"`
	Limit            int32       `db:"limit" json:"limit"`
}

type ListExecutionsRow struct {
	OrderID            string             `db:"order_id" json:"order_id"`
	ProviderAlias      string             `db:"provider_alias" json:"provider_alias"`
	StrategyInstanceID string             `db:"strategy_instance_id" json:"strategy_instance_id"`
	ExecutionID        string             `db:"execution_id" json:"execution_id"`
	FillQuantityText   string             `db:"fill_quantity_text" json:"fill_quantity_text"`
	FillPriceText      string             `db:"fill_price_text" json:"fill_price_text"`
	FeeText            string             `db:"fee_text" json:"fee_text"`
	FeeAsset           pgtype.Text        `db:"fee_asset" json:"fee_asset"`
	Liquidity          pgtype.Text        `db:"liquidity" json:"liquidity"`
	TradedAt           pgtype.Timestamptz `db:"traded_at" json:"traded_at"`
	MetadataJson       []byte             `db:"metadata_json" json:"metadata_json"`
	CreatedAt          pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) ListExecutions(ctx context.Context, arg ListExecutionsParams) ([]ListExecutionsRow, error) {
	rows, err := q.db.Query(ctx, listExecutions,
		arg.StrategyInstance,
		arg.ProviderAlias,
		arg.OrderID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListExecutionsRow
	for rows.Next() {
		var i ListExecutionsRow
		if err := rows.Scan(
			&i.OrderID,
			&i.ProviderAlias,
			&i.StrategyInstanceID,
			&i.ExecutionID,
			&i.FillQuantityText,
			&i.FillPriceText,
			&i.FeeText,
			&i.FeeAsset,
			&i.Liquidity,
			&i.TradedAt,
			&i.MetadataJson,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExecutionsForOrder = `-- name: ListExecutionsForOrder :many
SELECT id, order_id, provider_id, execution_id, fill_quantity, fill_price, fee, fee_asset, liquidity, traded_at, metadata, created_at FROM executions
WHERE order_id = $1::uuid
ORDER BY traded_at ASC
`

func (q *Queries) ListExecutionsForOrder(ctx context.Context, orderID pgtype.UUID) ([]Execution, error) {
	rows, err := q.db.Query(ctx, listExecutionsForOrder, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Execution
	for rows.Next() {
		var i Execution
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProviderID,
			&i.ExecutionID,
			&i.FillQuantity,
			&i.FillPrice,
			&i.Fee,
			&i.FeeAsset,
			&i.Liquidity,
			&i.TradedAt,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
