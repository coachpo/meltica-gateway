// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: providers.sql

package sqlc

import (
	"context"
)

const deleteProviderByAlias = `-- name: DeleteProviderByAlias :exec
DELETE FROM providers WHERE alias = $1::text
`

func (q *Queries) DeleteProviderByAlias(ctx context.Context, alias string) error {
	_, err := q.db.Exec(ctx, deleteProviderByAlias, alias)
	return err
}

const getProviderByAlias = `-- name: GetProviderByAlias :one
SELECT id, alias, display_name, adapter_identifier, connection, status, metadata, created_at, updated_at FROM providers WHERE alias = $1::text
`

func (q *Queries) GetProviderByAlias(ctx context.Context, alias string) (Provider, error) {
	row := q.db.QueryRow(ctx, getProviderByAlias, alias)
	var i Provider
	err := row.Scan(
		&i.ID,
		&i.Alias,
		&i.DisplayName,
		&i.AdapterIdentifier,
		&i.Connection,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProviderID = `-- name: GetProviderID :one
SELECT id FROM providers WHERE alias = $1::text
`

func (q *Queries) GetProviderID(ctx context.Context, alias string) (int64, error) {
	row := q.db.QueryRow(ctx, getProviderID, alias)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const listProviders = `-- name: ListProviders :many
SELECT id, alias, display_name, adapter_identifier, connection, status, metadata, created_at, updated_at FROM providers ORDER BY alias
`

func (q *Queries) ListProviders(ctx context.Context) ([]Provider, error) {
	rows, err := q.db.Query(ctx, listProviders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Provider
	for rows.Next() {
		var i Provider
		if err := rows.Scan(
			&i.ID,
			&i.Alias,
			&i.DisplayName,
			&i.AdapterIdentifier,
			&i.Connection,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertProvider = `-- name: UpsertProvider :one
INSERT INTO providers (
    alias,
    display_name,
    adapter_identifier,
    connection,
    status,
    metadata,
    updated_at
)
VALUES (
    $1::text,
    $2::text,
    $3::text,
    COALESCE($4::jsonb, '{}'::jsonb),
    $5::text,
    COALESCE($6::jsonb, '{}'::jsonb),
    NOW()
)
ON CONFLICT (alias) DO
UPDATE SET
    display_name = EXCLUDED.display_name,
    adapter_identifier = EXCLUDED.adapter_identifier,
    connection = EXCLUDED.connection,
    status = EXCLUDED.status,
    metadata = EXCLUDED.metadata,
    updated_at = NOW()
RETURNING id, alias, display_name, adapter_identifier, connection, status, metadata, created_at, updated_at
`

type UpsertProviderParams struct {
	Alias             string `db:"alias" json:"alias"`
	DisplayName       string `db:"display_name" json:"display_name"`
	AdapterIdentifier string `db:"adapter_identifier" json:"adapter_identifier"`
	Connection        []byte `db:"connection" json:"connection"`
	Status            string `db:"status" json:"status"`
	Metadata          []byte `db:"metadata" json:"metadata"`
}

func (q *Queries) UpsertProvider(ctx context.Context, arg UpsertProviderParams) (Provider, error) {
	row := q.db.QueryRow(ctx, upsertProvider,
		arg.Alias,
		arg.DisplayName,
		arg.AdapterIdentifier,
		arg.Connection,
		arg.Status,
		arg.Metadata,
	)
	var i Provider
	err := row.Scan(
		&i.ID,
		&i.Alias,
		&i.DisplayName,
		&i.AdapterIdentifier,
		&i.Connection,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
