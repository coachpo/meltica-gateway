// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: balances.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const latestBalanceForAsset = `-- name: LatestBalanceForAsset :one
SELECT id, provider_id, asset, total, available, snapshot_at, metadata, created_at, updated_at
FROM balances
WHERE provider_id = $1::bigint AND asset = $2::text
ORDER BY snapshot_at DESC
LIMIT 1
`

type LatestBalanceForAssetParams struct {
	ProviderID int64  `db:"provider_id" json:"provider_id"`
	Asset      string `db:"asset" json:"asset"`
}

func (q *Queries) LatestBalanceForAsset(ctx context.Context, arg LatestBalanceForAssetParams) (Balance, error) {
	row := q.db.QueryRow(ctx, latestBalanceForAsset, arg.ProviderID, arg.Asset)
	var i Balance
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.Asset,
		&i.Total,
		&i.Available,
		&i.SnapshotAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listBalances = `-- name: ListBalances :many
SELECT
    p.alias AS provider_alias,
    b.asset,
    b.total::text AS total_text,
    b.available::text AS available_text,
    b.snapshot_at,
    b.metadata AS metadata_json,
    b.created_at,
    b.updated_at
FROM balances b
JOIN providers p ON p.id = b.provider_id
WHERE (
    $1::text IS NULL
    OR p.alias = $1::text
) AND (
    $2::text IS NULL
    OR b.asset = $2::text
)
ORDER BY b.snapshot_at DESC
LIMIT $3::int
`

type ListBalancesParams struct {
	ProviderAlias pgtype.Text `db:"provider_alias" json:"provider_alias"`
	Asset         pgtype.Text `db:"asset" json:"asset"`
	Limit         int32       `db:"limit" json:"limit"`
}

type ListBalancesRow struct {
	ProviderAlias string             `db:"provider_alias" json:"provider_alias"`
	Asset         string             `db:"asset" json:"asset"`
	TotalText     string             `db:"total_text" json:"total_text"`
	AvailableText string             `db:"available_text" json:"available_text"`
	SnapshotAt    time.Time          `db:"snapshot_at" json:"snapshot_at"`
	MetadataJson  []byte             `db:"metadata_json" json:"metadata_json"`
	CreatedAt     pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListBalances(ctx context.Context, arg ListBalancesParams) ([]ListBalancesRow, error) {
	rows, err := q.db.Query(ctx, listBalances, arg.ProviderAlias, arg.Asset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBalancesRow
	for rows.Next() {
		var i ListBalancesRow
		if err := rows.Scan(
			&i.ProviderAlias,
			&i.Asset,
			&i.TotalText,
			&i.AvailableText,
			&i.SnapshotAt,
			&i.MetadataJson,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBalancesSince = `-- name: ListBalancesSince :many
SELECT id, provider_id, asset, total, available, snapshot_at, metadata, created_at, updated_at
FROM balances
WHERE provider_id = $1::bigint
  AND snapshot_at >= $2::timestamptz
ORDER BY snapshot_at DESC
`

type ListBalancesSinceParams struct {
	ProviderID int64              `db:"provider_id" json:"provider_id"`
	Since      pgtype.Timestamptz `db:"since" json:"since"`
}

func (q *Queries) ListBalancesSince(ctx context.Context, arg ListBalancesSinceParams) ([]Balance, error) {
	rows, err := q.db.Query(ctx, listBalancesSince, arg.ProviderID, arg.Since)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Balance
	for rows.Next() {
		var i Balance
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.Asset,
			&i.Total,
			&i.Available,
			&i.SnapshotAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertBalanceSnapshot = `-- name: UpsertBalanceSnapshot :one
INSERT INTO balances (
    provider_id,
    asset,
    total,
    available,
    snapshot_at,
    metadata
)
VALUES (
    $1::bigint,
    $2::text,
    $3::numeric,
    $4::numeric,
    $5::timestamptz,
    COALESCE($6::jsonb, '{}'::jsonb)
)
ON CONFLICT (provider_id, asset, snapshot_at) DO UPDATE
SET
    total = EXCLUDED.total,
    available = EXCLUDED.available,
    metadata = EXCLUDED.metadata,
    updated_at = NOW()
RETURNING id, provider_id, asset, total, available, snapshot_at, metadata, created_at, updated_at
`

type UpsertBalanceSnapshotParams struct {
	ProviderID int64              `db:"provider_id" json:"provider_id"`
	Asset      string             `db:"asset" json:"asset"`
	Total      pgtype.Numeric     `db:"total" json:"total"`
	Available  pgtype.Numeric     `db:"available" json:"available"`
	SnapshotAt pgtype.Timestamptz `db:"snapshot_at" json:"snapshot_at"`
	Metadata   []byte             `db:"metadata" json:"metadata"`
}

func (q *Queries) UpsertBalanceSnapshot(ctx context.Context, arg UpsertBalanceSnapshotParams) (Balance, error) {
	row := q.db.QueryRow(ctx, upsertBalanceSnapshot,
		arg.ProviderID,
		arg.Asset,
		arg.Total,
		arg.Available,
		arg.SnapshotAt,
		arg.Metadata,
	)
	var i Balance
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.Asset,
		&i.Total,
		&i.Available,
		&i.SnapshotAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
