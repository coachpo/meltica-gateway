// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getOrderByClientID = `-- name: GetOrderByClientID :one
SELECT id, provider_id, strategy_instance_id, client_order_id, instrument, side, order_type, quantity, price, state, external_order_ref, placed_at, acknowledged_at, completed_at, metadata, created_at, updated_at FROM orders
WHERE provider_id = $1::bigint AND client_order_id = $2::text
`

type GetOrderByClientIDParams struct {
	ProviderID    int64  `db:"provider_id" json:"provider_id"`
	ClientOrderID string `db:"client_order_id" json:"client_order_id"`
}

func (q *Queries) GetOrderByClientID(ctx context.Context, arg GetOrderByClientIDParams) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByClientID, arg.ProviderID, arg.ClientOrderID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.StrategyInstanceID,
		&i.ClientOrderID,
		&i.Instrument,
		&i.Side,
		&i.OrderType,
		&i.Quantity,
		&i.Price,
		&i.State,
		&i.ExternalOrderRef,
		&i.PlacedAt,
		&i.AcknowledgedAt,
		&i.CompletedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertOrder = `-- name: InsertOrder :one
INSERT INTO orders (
    id,
    provider_id,
    strategy_instance_id,
    client_order_id,
    instrument,
    side,
    order_type,
    quantity,
    price,
    state,
    external_order_ref,
    placed_at,
    acknowledged_at,
    completed_at,
    metadata
)
VALUES (
    COALESCE($1::uuid, gen_random_uuid()),
    $2::bigint,
    $3::uuid,
    $4::text,
    $5::text,
    $6::text,
    $7::text,
    $8::numeric,
    $9::numeric,
    $10::text,
    $11::text,
    COALESCE($12::timestamptz, NOW()),
    $13::timestamptz,
    $14::timestamptz,
    COALESCE($15::jsonb, '{}'::jsonb)
)
ON CONFLICT (id) DO NOTHING
RETURNING id, provider_id, strategy_instance_id, client_order_id, instrument, side, order_type, quantity, price, state, external_order_ref, placed_at, acknowledged_at, completed_at, metadata, created_at, updated_at
`

type InsertOrderParams struct {
	ID                 pgtype.UUID        `db:"id" json:"id"`
	ProviderID         int64              `db:"provider_id" json:"provider_id"`
	StrategyInstanceID pgtype.UUID        `db:"strategy_instance_id" json:"strategy_instance_id"`
	ClientOrderID      string             `db:"client_order_id" json:"client_order_id"`
	Instrument         string             `db:"instrument" json:"instrument"`
	Side               string             `db:"side" json:"side"`
	OrderType          string             `db:"order_type" json:"order_type"`
	Quantity           pgtype.Numeric     `db:"quantity" json:"quantity"`
	Price              pgtype.Numeric     `db:"price" json:"price"`
	State              string             `db:"state" json:"state"`
	ExternalOrderRef   pgtype.Text        `db:"external_order_ref" json:"external_order_ref"`
	PlacedAt           pgtype.Timestamptz `db:"placed_at" json:"placed_at"`
	AcknowledgedAt     pgtype.Timestamptz `db:"acknowledged_at" json:"acknowledged_at"`
	CompletedAt        pgtype.Timestamptz `db:"completed_at" json:"completed_at"`
	Metadata           []byte             `db:"metadata" json:"metadata"`
}

func (q *Queries) InsertOrder(ctx context.Context, arg InsertOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, insertOrder,
		arg.ID,
		arg.ProviderID,
		arg.StrategyInstanceID,
		arg.ClientOrderID,
		arg.Instrument,
		arg.Side,
		arg.OrderType,
		arg.Quantity,
		arg.Price,
		arg.State,
		arg.ExternalOrderRef,
		arg.PlacedAt,
		arg.AcknowledgedAt,
		arg.CompletedAt,
		arg.Metadata,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.StrategyInstanceID,
		&i.ClientOrderID,
		&i.Instrument,
		&i.Side,
		&i.OrderType,
		&i.Quantity,
		&i.Price,
		&i.State,
		&i.ExternalOrderRef,
		&i.PlacedAt,
		&i.AcknowledgedAt,
		&i.CompletedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listOrders = `-- name: ListOrders :many
SELECT
    o.id::text AS order_id,
    p.alias AS provider_alias,
    COALESCE(si.instance_id, '') AS strategy_instance_id,
    o.client_order_id,
    o.instrument,
    o.side,
    o.order_type,
    o.quantity::text AS quantity_text,
    COALESCE(o.price::text, ''::text)::text AS price_text,
    o.state,
    o.external_order_ref,
    o.placed_at,
    o.acknowledged_at,
    o.completed_at,
    o.metadata AS metadata_json,
    o.created_at,
    o.updated_at
FROM orders o
JOIN providers p ON p.id = o.provider_id
LEFT JOIN strategy_instances si ON si.id = o.strategy_instance_id
WHERE (
    $1::text IS NULL
    OR COALESCE(si.instance_id, '') = $1::text
) AND (
    $2::text IS NULL
    OR p.alias = $2::text
) AND (
    $3::text[] IS NULL
    OR o.state = ANY($3::text[])
)
ORDER BY o.placed_at DESC
LIMIT $4::int
`

type ListOrdersParams struct {
	StrategyInstance pgtype.Text `db:"strategy_instance" json:"strategy_instance"`
	ProviderAlias    pgtype.Text `db:"provider_alias" json:"provider_alias"`
	States           []string    `db:"states" json:"states"`
	Limit            int32       `db:"limit" json:"limit"`
}

type ListOrdersRow struct {
	OrderID            string             `db:"order_id" json:"order_id"`
	ProviderAlias      string             `db:"provider_alias" json:"provider_alias"`
	StrategyInstanceID string             `db:"strategy_instance_id" json:"strategy_instance_id"`
	ClientOrderID      string             `db:"client_order_id" json:"client_order_id"`
	Instrument         string             `db:"instrument" json:"instrument"`
	Side               string             `db:"side" json:"side"`
	OrderType          string             `db:"order_type" json:"order_type"`
	QuantityText       string             `db:"quantity_text" json:"quantity_text"`
	PriceText          string             `db:"price_text" json:"price_text"`
	State              string             `db:"state" json:"state"`
	ExternalOrderRef   pgtype.Text        `db:"external_order_ref" json:"external_order_ref"`
	PlacedAt           pgtype.Timestamptz `db:"placed_at" json:"placed_at"`
	AcknowledgedAt     pgtype.Timestamptz `db:"acknowledged_at" json:"acknowledged_at"`
	CompletedAt        pgtype.Timestamptz `db:"completed_at" json:"completed_at"`
	MetadataJson       []byte             `db:"metadata_json" json:"metadata_json"`
	CreatedAt          pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]ListOrdersRow, error) {
	rows, err := q.db.Query(ctx, listOrders,
		arg.StrategyInstance,
		arg.ProviderAlias,
		arg.States,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersRow
	for rows.Next() {
		var i ListOrdersRow
		if err := rows.Scan(
			&i.OrderID,
			&i.ProviderAlias,
			&i.StrategyInstanceID,
			&i.ClientOrderID,
			&i.Instrument,
			&i.Side,
			&i.OrderType,
			&i.QuantityText,
			&i.PriceText,
			&i.State,
			&i.ExternalOrderRef,
			&i.PlacedAt,
			&i.AcknowledgedAt,
			&i.CompletedAt,
			&i.MetadataJson,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByProvider = `-- name: ListOrdersByProvider :many
SELECT id, provider_id, strategy_instance_id, client_order_id, instrument, side, order_type, quantity, price, state, external_order_ref, placed_at, acknowledged_at, completed_at, metadata, created_at, updated_at FROM orders
WHERE provider_id = $1::bigint
ORDER BY placed_at DESC
LIMIT $3::int OFFSET $2::int
`

type ListOrdersByProviderParams struct {
	ProviderID int64 `db:"provider_id" json:"provider_id"`
	Offset     int32 `db:"offset" json:"offset"`
	Limit      int32 `db:"limit" json:"limit"`
}

func (q *Queries) ListOrdersByProvider(ctx context.Context, arg ListOrdersByProviderParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrdersByProvider, arg.ProviderID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.StrategyInstanceID,
			&i.ClientOrderID,
			&i.Instrument,
			&i.Side,
			&i.OrderType,
			&i.Quantity,
			&i.Price,
			&i.State,
			&i.ExternalOrderRef,
			&i.PlacedAt,
			&i.AcknowledgedAt,
			&i.CompletedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderState = `-- name: UpdateOrderState :one
UPDATE orders
SET
    state = $1::text,
    acknowledged_at = COALESCE($2::timestamptz, acknowledged_at),
    completed_at = COALESCE($3::timestamptz, completed_at),
    metadata = COALESCE($4::jsonb, metadata),
    updated_at = NOW()
WHERE id = $5::uuid
RETURNING id, provider_id, strategy_instance_id, client_order_id, instrument, side, order_type, quantity, price, state, external_order_ref, placed_at, acknowledged_at, completed_at, metadata, created_at, updated_at
`

type UpdateOrderStateParams struct {
	State          string             `db:"state" json:"state"`
	AcknowledgedAt pgtype.Timestamptz `db:"acknowledged_at" json:"acknowledged_at"`
	CompletedAt    pgtype.Timestamptz `db:"completed_at" json:"completed_at"`
	Metadata       []byte             `db:"metadata" json:"metadata"`
	ID             pgtype.UUID        `db:"id" json:"id"`
}

func (q *Queries) UpdateOrderState(ctx context.Context, arg UpdateOrderStateParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderState,
		arg.State,
		arg.AcknowledgedAt,
		arg.CompletedAt,
		arg.Metadata,
		arg.ID,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.StrategyInstanceID,
		&i.ClientOrderID,
		&i.Instrument,
		&i.Side,
		&i.OrderType,
		&i.Quantity,
		&i.Price,
		&i.State,
		&i.ExternalOrderRef,
		&i.PlacedAt,
		&i.AcknowledgedAt,
		&i.CompletedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
